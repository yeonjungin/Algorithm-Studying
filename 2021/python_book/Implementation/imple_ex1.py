'''
Chapter4 구현
4-1 상하좌우 문제 p111
이 문제는 시뮬레이션 문제에 해당한다.
(일련의 명령에 따라서 개체를 차례대로 이동시키기 때문이다)
시뮬레이션 문제? : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 문제

'''
# 문제1
n=int(input())
x,y=1,1

# ['R', 'R', 'R', 'U', 'D', 'D']
# 숫자를 여러 개 입력 받을 떈 map(int,input().split())을 쓰지만,
# 문자를 입력 받을 땐 input().split()만 써도 리스트 형태로 받아온다.

'''
-1은 왼쪽, 1은 오른쪽 dx(x축)
-1은 위쪽, 1은 아래쪽 dy(y축)
x축에는 왼쪽과 오른쪽에 해당하는 값만 쓰고, y축에는 위쪽과 아래쪽에 해당하는 값만 다루게끔 코드 작성

move_type리스트에는 방향을 나타내는 문자가 들어있다.
for문을 이용하여 앞서 입력한 방향 문자를 불러와서, 해당하는 값

오른쪽이나 왼쪽으로 이동하면, y의 값이 +1 or -1 
위쪽이나 아래쪽으로 이동하면, x의 값이 -1 or +1

L이면, y의 값이 -1씩 감소한다. 
move_types에서는 0번째 인덱스에 있으니 dy 리스트의 0번째 인덱스 값은 -1이 된다.

하나만 더 해보면,
D이면, X의 값이 +1 증가한다.
move_types에서는 D의 인덱스 값이 3이다.
따라서 dx의 3번쨰 인덱스는 1이 된다.
'''

'''
길이 막혀서 가지 못하는 상황도 대비를 해야 한다.
공간을 벗어나는 경우에 대해 생각해보자
위쪽, 아래쪽, 왼쪽, 오른쪽이 경계밖으로 나가는 경우에 해당한다.
위쪽으로 못 가려면 x의 값이 1 미만인 경우, 
아래쪽으로 못 가는 경우는 x의 값이 N 초과인 경우,
오른쪽으로 못 가는 경우는 y의 값이 N 초과인 경우,
마지막으로 왼쪽으로 못 가는 경우는 y의 값이 1 미만인 경우에 해당하고,
if문을 이용하면 구현이 가능하다.
'''
plans=input().split()

dx=[0,0,-1,1]
dy=[-1,1,0,0]

move_types=['L','R','U','D']

for plan in plans:
    for i in range(len(move_types)):
        if plan==move_types[i]:
            nx=x+dx[i]
            ny=y+dy[i]
    if nx>n or nx<1 or ny>n or ny<1:
        continue
    x,y=nx,ny
print(x,y)
